<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type">
    <title></title>
    <meta name="GENERATOR" content="OpenOffice.org 3.4.1  (Unix)">
    <meta name="CREATED" content="20130720;22180300">
    <meta name="CHANGED" content="20130729;17353700">
    <style type="text/css">
	<!--
		H2.ctl { font-family: "Arial Unicode MS" }
		H3.ctl { font-family: "Arial Unicode MS" }
		H4.ctl { font-family: "Arial Unicode MS" }
	-->
	</style>
  </head>
  <body dir="LTR" style="max-width: 650px" lang="de-DE">
    <h1>Raspberry Pi als Bordcomputer / Navigation im Browser </h1>
    <p>03.01.2015</p>
    <p><br>
    </p>
    <h2 class="western">Motivation</h2>
    <p>Nachdem ich schon eine ganze Weile mit Rasterkarten unterwegs navigiere
      (erst unter Windows mit Seaclear, dann unter Windows, WindowsCE und OSX
      mit OpenCPN und OziExplorer) hatte ich schon eine ganze Weile nach
      Möglichkeiten gesucht, das zu erweitern und noch besser tauglich für
      unterwegs zu machen.</p>
    <p>Meine Wunschliste dabei war:</p>
    <ul>
      <li>
        <p>Navigation auf kleinen Geräten (Laptop ist immer ein wenig
          unhandlich) – 7 oder 10 Zoll Tablet wäre Ideal</p>
      </li>
      <li>
        <p>Navigation auch im Cockpit</p>
      </li>
      <li>
        <p>Trackaufzeichnung</p>
      </li>
      <li>
        <p>Verknüpfung mit der „on board“ Navigation (seit einiger Zeit habe ich
          ein RO4800 als Funke, das auch einen AIS Decoder hat – und ja auch
          schon GPS Daten bekommt)</p>
      </li>
      <li>
        <p>Nutzung der Rasterkarten (BSB, NV, alles was sich per Download über
          mobile atlas creator bekommen lässt...)</p>
      </li>
      <li>
        <p>Minimaler Installationsaufwand</p>
      </li>
      <li>
        <p>Klein, wenig Stromverbrauch (sollte möglichst immer laufen können)</p>
      </li>
      <li>
        <p>Wenig „Bastelarbeit“ - also möglichst keine eigenen Schaltungen löten</p>
      </li>
    </ul>
    <p>Irgendwann habe ich mal den raspberry pi entdeckt und nachdem er zu Hause
      jetzt schon eine Weile als media center arbeitet, dachte ich, dass der
      eine gute Basis für einen Bordcomputer abgeben könnte. </p>
    <p>Allerdings musste ich nach einiger Recherche feststellen, dass es noch
      keine fertige Software gab, die meinen Anforderungen genügen würde.
      Insbesondere die Einbettung der seriellen Schnittstellen (typisch
      seriell-usb-Wandler) macht immer wieder Mühe, da Linux hier immer etwas
      kreativ ist... </p>
    <p>Also habe ich beschlossen mich selbst daran zu machen. Im Folgenden will
      ich meine Lösung beschreiben, da es ja vielleicht Interessierte gibt, die
      es Nachnutzen möchten. Die gesamte Software steht zum download unter einer
      open source Lizenz bereit. </p>
    <p><br>
      <br>
    </p>
    <h2 class="western">Überblick </h2>
    <p><img src="overview.png" name="Grafik1" align="LEFT" border="0" width="600"><br
        clear="LEFT">
      Wie im Bild zu sehen, besteht die gesamte Lösung aus mehreren Teilen:</p>
    <ul>
      <li>
        <p>Einem Raspberry Pi mit einer server software (avnav_server.py), die
          die angeschlossenen Geräte (NMEA über Seriell-USB Wandler – z.B. PL
          2303), Bluetooth GPS,... abfragt, die Daten aufbereitet und per WLAN
          zur Verfügung stellt</p>
      </li>
      <li>
        <p>Einer Software für Windows/OSx/Linux, die zum Vorbereiten und
          Konvertieren der Karten dient</p>
      </li>
    </ul>
    <p>Über ein WLAN, das der raspberry pi als access point bereitstellt, können
      verschiedene Geräte auf die Daten zugreifen. Dabei gibt es mehrere
      Varianten:</p>
    <ul>
      <li>
        <p>Auf den Geräten (z.B. Ipad oder Laptop) kann eine Navigationssoftware
          laufen (getestet: InavX,OpenCPN), diese greifen über TCP auf die NMEA
          Daten zu. Navigationssoftware und Karten müssen natürlich auf den
          Geräten installiert sein.</p>
      </li>
      <li>
        <p>Auf den Geräten läuft nur ein Browser, die Navigation erfolgt per
          Java Script app, die vom raspberry bereitgestellt wird. Dazu muss nur
          die entsprechende URL aufgerufen werden. In diesem Falle ist auf den
          Geräten keine Software installiert, nur ein aktueller Browser muss
          vorhanden sein (getestet: Chrome unter Windows, OSX, Safari, Android
          ab 4.x – Chrom/Stock/Boat Browser, IOS, Blackberry stockBrowser,
          WebBrowser mini).</p>
      </li>
    </ul>
    <p>Die server software auf dem raspberry ist in python geschrieben und über
      ein xml file konfigurierbar (was im Normalfall aber nicht notwendig sein
      sollte). Ich stelle neben dieser Software auch ein fertiges Image für den
      raspberry zur Verfügung, dass nur noch auf eine SD-Karte installiert
      werden muss (Empfehlung: mindestens 8GB, mehr ist besser...).</p>
    <p>Die Web Applikation bietet eine&nbsp; Navigation mit Rasterkarten
      inklusive AIS Darstellung, Wegepunkt Navigation und Routing. Falls die
      Web-Applikation verwendet werden soll, müssen die Karten dafür auch auf
      dem raspberry installiert werden. Diese müssen dazu vorher auf dem PC
      (Windows, Osx, Linux) in das <a href="http://www.cgtk.co.uk/gemf">gemf</a>
      Format konvertiert werden. Im Wesentlichen können die folgenden
      Kartenquellen verarbeitet werden:</p>
    <ul>
      <li>
        <p>Alle Kartentypen, die die GDAL software lesen kann (also insbesondere
          BSB Karten)</p>
      </li>
      <li>
        <p>Mit Mobile Atlas Creator heruntergeladene Karten</p>
      </li>
      <li>
        <p>Zur Nutzung von NV digital Karten bitte ich um Kontaktaufnahme, hier
          ist die Einhaltung der Lizenzbedingungen ein Thema.</p>
      </li>
    </ul>
    <p>In den folgenden Abschnitten gehe ich auf die Funktion der einzelnen
      Teile ein wenig genauer ein.</p>
    <p><br>
      <br>
    </p>
    <h2 class="western">Die Server Software (avnav_server.py)</h2>
    <p>Auf dem raspberry pi ist zunächst ein<a href="http://www.raspberrypi.org/downloads">
        ganz normales Debian image</a> installiert (ca. 2GB). Dazu kommen einige
      Zusatzpakete (liste siehe unten) und meine Software. </p>
    <p>Der Hauptbestandteil der Sofware auf dem raspberry pi ist ein in python
      geschriebener Server. Im Folgenden beschreibe ich in groben Zügen, was
      dieser Server intern tut.</p>
    <p><img src="software.png" name="Grafik2" align="LEFT" border="0" width="600"><br
        clear="LEFT">
      <br>
      <br>
    </p>
    <p>Dieser Server versucht alle am raspberry angeschlossenen seriellen Geräte
      zu erkennen und deren NMEA Daten zu lesen. Typisch werden die Geräte über
      seriell-usb Wandler angeschlossen (bei mir z.B. PL2303). Man muss ein
      wenig aufpassen, dass man einen Wandler hat, der vom Raspberry auch sauber
      unterstützt wird - siehe z.B. <a href="http://elinux.org/RPi_VerifiedPeripherals#USB_UART_and_USB_to_Serial_.28RS-232.29_adapters">hier</a>.
      Da das Verwalten der seriellen Schnittstellen unter Linux etwas magisch
      ist, scant der Server (per Dbus) die angeschlossenen Geräte auf eine
      entsprechende serielle Klasse und ermittelt deren Schnittstelle (device).
      Anschliessend versucht er ein auto bauding zwischen 4800 und 34000 Baud
      und bemüht sich, NMEA Daten zu erkennen. Falls keine Daten empfangen
      werden, wird die Schnittstelle geschlossen und das Spiel beginnt von vorn.
      Damit „überlebt“ er auch das anschliessen/abstecken von Wandlern im
      Betrieb oder das An- bzw. Abschalten von Geräten. Bei mir hängt ein RO4800
      mit AIS Decoder dran, die GPS Daten werden durchgereicht. Alternativ
      versucht er auch Kontakt zu seriellen Bluetooth Geräten aufzunehmen, falls
      er per discovery welche findet und versucht ebenfalls NMEA Daten zu Lesen.
      Getestet bei mir mit einer Holux GPS Slim236. In diesem Sinne arbeitet er
      auch als NMEA Multiplexer.</p>
    <p>Alle GPS-Daten werden intern in eine Liste eingefügt und per TCP
      bereitgestellt. Verbundene TCP Empfänger (z.B. OpenCPN) bekommen so jeden
      empfangenen Datensatz weitergereicht. Per Default "lauscht" der server
      (intern:SocketWriter) auf Port 34567.</p>
    <p>Anschliessend werden die NMEA Daten an den Decoder weitergereicht. Auf
      dem raspberry benutze ich dazu <a href="http://catb.org/gpsd/">gpsd</a>.
      Leider liess der sich nicht verwenden, um direkt die seriellen
      Schnittstellen zu lesen, daher macht der avnnav_server einen Socket auf,
      an den sich der gpsd connected und von dem er die Daten liest. Das Starten
      des gpsd übernimmt ebenfalls der anav server. Am „anderen Ende“ werden
      über die gpsd python Schnittstelle die dekodierten Daten ausgelesen (gps
      Daten und AIS Daten) und im Server abgelegt ("NMEA decoded data") für den
      Zugriff per HTTP aus der WebApp. Der gpsd wird überwacht und bei Fehlern
      neu gestartet. Zusätzlich werden die dekodierten Daten auch benutzt um
      Track Dateien zu schreiben.</p>
    <p>Über den integrierten WebServer kann der Zugriff auf diese dekodierten
      Daten erfolgen (per HTTP GET, Antwort als json).</p>
    <p><span style="font-style: italic;">Neu ab Versionen 2015-01-xxx:</span></p>
    <p><span style="font-style: italic;">Der Route-Handler wertet eingestellte
        Routen (bzw. Wegepunkte) aus und berechnet daraus die Daten für eine
        Autopilot-Steuerung. Diese werden als RMB NMEA Datensätze wieder in die
        NMEA Daten eingespeist und stehen so an allen Schnittstellen zur
        Verfügung.</span></p>
    <p><span style="font-style: italic;">Es gibt dazu einen Seriell Writer, der
        die Daten über USB-Seriell Wandler ausgeben kann.</span></p>
    <p>Falls gültige GPS Zeitinformationen empfangen werden, wird die Systemzeit
      des raspberry entsprechend eingestellt.</p>
    <p>Auf dem raspberry gibt es noch einen service, der den avnav_server beim
      Systemstart automatisch startet und es auch ermöglicht, ihn geordnet zu
      beenden.</p>
    <p>Da der gesamte server in python geschrieben ist, kann er auch (vor allem
      zu Testzwecken) unter Windows oder Osx (Mac), Linux laufen. Dazu muss
      python ab 2.6 installiert sein, falls reale serielle Daten gelesen werden
      sollen noch <a href="http://pyserial.sourceforge.net/">pyserial</a>. In
      diesem Falle steht gpsd als Dekoder ja nicht zur Verfügung, es wird dann
      ein interner Dekoder genutzt, der die wichtigsten NMEA Sequenzen dekodiert
      und ein AIS Dekoder in python, der ebenfalls durch das gpsd Projekt
      bereitgestellt wird.</p>
    <p>Der Server kann in weiten Grenzen durch ein xml File konfiguriert werden,
      für die verschiedenen Nutzungsfälle liefere ich dokumentierte Beispiele
      mit.</p>
    <p>In der Auslieferung für den pi ist die Software so konfiguriert, dass sie
      alle per USB angebundenen seriellen Schnittstellen öffnet, dort versucht
      NMEA DAten zu erkennen (per auto-bauding von 4800 B/s bis 38400 B/s) und
      diese dann verarbeitet. Wenn eine gültige Uhrzeit erkannt wird, wird die
      Systemzeit gesetzt. Ausserdem wird (falls ein Bluetooth adapter erkannt
      wurde) versucht, mit allen seriellen Bluetooth Geräten Verbindung
      aufzunehmen und auch von dort NMEA Daten zu empfangen. Damit sollte im
      Normalfall keine weitere Konfiguration nötig sein und NMEA Daten sofort
      erkannt werden (kann man im Status display prüfen - s.u.).</p>
    <p>Die ausgelieferte avnav_server.xml Datei enthält Kommentare, so das Anpassungen
      an die eigenen Bedürfnisse einfach möglich sein sollten.</p>
    <p>Die Software ist auf <a href="https://github.com/wellenvogel/avnav">github</a>
      verfügbar - downloads auf <a href="http://www.wellenvogel.net/software/avnav/downloads/index.php">wellenvogel.de</a>.</p>
    <h2 class="western">Software auf dem raspberry</h2>
    <p>Auf dem raspberry ist die Software in der folgenden Verzeichnisstruktur
      installiert:</p>
    <table border="1" cellpadding="4" cellspacing="4" width="100%">
      <colgroup><col width="73*"> <col width="183*"> </colgroup>
      <tbody>
        <tr valign="TOP">
          <th width="28%">
            <p>Verzeichnis</p>
          </th>
          <th width="72%">
            <p>Inhalt</p>
          </th>
        </tr>
        <tr valign="TOP">
          <td width="28%">
            <p>/data/</p>
          </td>
          <td width="72%">
            <p>Eine separate data partition. Diese wird automatisch beim ersten
              Hochfahren angelegt und umfasst die gesamte Speicherkarte (- ca.
              2GB für die boot partition und die root partition). Das Filesystem
              ist so angelegt, dass es gut mit sehr vielen kleinen Dateien
              umgehen kann (für die Karten).</p>
          </td>
        </tr>
        <tr valign="TOP">
          <td width="28%">
            <p>/data/avnav/charts</p>
          </td>
          <td width="72%">
            <p>Verzeichnis für die Kartendateien. Jeder verwendete Kartensatz
              muss in einem separaten Unterverzeichnis liegen. Dort hinein
              müssen jeweils die avnav.xml und die erzeugten Kartenverzeichnisse
              kopiert werden (siehe<a href="#Chartconvert"> Karten konvertieren</a>).</p>
          </td>
        </tr>
        <tr valign="TOP">
          <td width="28%">
            <p>/dava/avnav/log</p>
          </td>
          <td width="72%">
            <p>logfiles</p>
          </td>
        </tr>
        <tr valign="TOP">
          <td width="28%">
            <p>/data/avnav/tracks</p>
          </td>
          <td width="72%">
            <p>Die trackfiles. Sie werden in einem File pro Tag gespeichert.
              Momentan ist das ein simples csv Format, eine Konvertierung nach
              gpx steht schon auf der todo Liste.</p>
          </td>
        </tr>
        <tr valign="TOP">
          <td width="28%">
            <p>/home/pi/avnav/data</p>
          </td>
          <td width="72%">
            <p>Links zu /data/avnav/charts, /data/avnav/tracks, /data/avnav/log.
              Ausserdem die config Datei avnav_server.xml. Beim ersten Start
              wird sie dorthin kopiert, danach aber nicht wieder überschrieben.
              Etwaige Anpassungen also hier.</p>
          </td>
        </tr>
        <tr valign="TOP">
          <td width="28%">
            <p>/home/pi/avnav/setup.sh</p>
          </td>
          <td width="72%">
            <p>Kann als root aufgerufen werden, um ein update der Software zu
              machen (bei Internet-Verbindung):<br>
              setup.sh update &lt;url&gt;</p>
          </td>
        </tr>
        <tr valign="TOP">
          <td width="28%">
            <p>/home/pi/avnav/program</p>
          </td>
          <td width="72%">
            <p>Das Program-Verzeichnis.</p>
          </td>
        </tr>
        <tr valign="TOP">
          <td width="28%">
            <p>/home/pi/avnav/program/server</p>
          </td>
          <td width="72%">
            <p>Der eigentliche server: avnav_server.py, <br>
              Der ais Dekoder (aus dem gpsd Projekt): ais.py, <br>
              Konvertierung von MOBAC atlas files zu avnav.xml:
              create_overview.py</p>
          </td>
        </tr>
        <tr valign="TOP">
          <td width="28%">
            <p>/home/pi/avnav/program/raspberry</p>
          </td>
          <td width="72%">
            <p>Raspberry spezifische software Anteile (u.a. der service zum
              Starten von avnav_server)</p>
          </td>
        </tr>
        <tr valign="TOP">
          <td width="28%">
            <p>/home/pi/avnav/program/libraries</p>
          </td>
          <td width="72%">
            <p>Die verwendeten JS libraries für die WebApp.<br>
              Das sind u.a.:<br>
              * <a href="http://www.openlayers.org/">OpenLayers</a><br>
              * <a href="http://jquery.com/">jQuery</a><br>
              * <a href="http://lesscss.org/">less</a><br>
              * <a href="http://www.movable-type.co.uk/scripts/latlong.html">movable-type</a>
              (java script functions von movable type)</p>
          </td>
        </tr>
        <tr valign="TOP">
          <td width="28%">
            <p>/home/pi/avnav/program/viewer</p>
          </td>
          <td width="72%">
            <p>Die WebApp.</p>
          </td>
        </tr>
        <tr valign="TOP">
          <td width="28%">
            <p>/etc/init.d/</p>
          </td>
          <td width="72%">
            <p>Die services, die zum Starten benutzt werden (links zu
              /home/pi/avnav/program/raspberry):<br>
              * avnav – der server<br>
              * check_parts – service, der prüft, ob die data partition schon da
              ist und sie im Zweifel anlegt<br>
              * check_wlan – prüft, ob das interface wlan0 eine IP adresse hat
              und macht im Zweifel ein ifdown/ifup – damit funktioniert das Wlan
              deutlich stabiler</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p>&nbsp;</p>
    <p>Bis auf die init scripte läuft die gesamte Software unter dem Nutzer pi.
      Die Installation muss allerdings als root erfolgen.</p>
    <p>Standardmässig wird die SD Karte für den pi mit 2 Partitionen versehen:</p>
    <ul>
      <li>
        <p>eine FAT32 formatierte boot Partition (ca. 60MB), gemounted nach
          /boot</p>
      </li>
      <li>
        <p>eine root partition, ca. 2GB</p>
      </li>
    </ul>
    <p>Bei meinem Image kommt dazu noch eine separate /data partition mit dem
      Rest der SD-Karte (wird beim ersten Start automatisch erzeugt). </p>
    <p>Die Installation der Software hängt stark davon ab, ob mein Image
      verwendet wird, oder ob von einem „stock“ Image ausgegangen wird. Beide
      Varianten beschreibe ich kurz.</p>
    <h3 class="western">Installation mit avnav image</h3>
    <p>Für diese Variante einfach unter Windows/Linux/OSx das image von <a href="http://www.wellenvogel.de/software/avnav/download">wellenvogel.de</a>
      herunterladen und wie unter <a href="http://www.raspberrypi.org/downloads">http://www.raspberrypi.org/downloads</a>
      (raw images) beschrieben auf eine SD Karte spielen. Danach muss man sich
      einmal auf dem pi einloggen und ggf. ein paar Anpassungen vornehmen. Am
      einfachsten geht das, wenn man den pi im LAN anschließt und einen
      router/dhcp-server (z.B. Fritz Box) aktiv hat. Dann holt er sich per DHCP
      eine IP Adresse. Diese kann man auf dem Router sehen bzw. unter Linux z.B.
      per ping -b &lt;brodcast-address&gt; herausfinden. Alternativ kann man
      auch Tastatur + Bildschirm an den Pi direkt anschliessen.</p>
    <p>Die Paßworte sind auf Standardwerte gesetzt – also login pi, Paßwort
      raspberry. Per sudo -i wechselt man in eine root shell. Man sollte
      kontrollieren, ob die /data partition existier und gemounted ist (df -h,
      mount). Anschliessend sollte man noch das Paßwort für den user pi ändern
      (passwd). Per sudo raspi-config (siehe u.a. <a href="http://www.raspberrypi.org/phpBB3/viewtopic.php?f=91&amp;t=4751">hier</a>)
      sollte ein Übertakten auf 1GHz eingestellt werden.</p>
    <p>Am schwierigsten kann sich das Aufsetzen des WLAN gestalten. Das hängt
      vom verwendeten Adapter ab. Ich habe einen rtl8192cu verwendet (TP-Link
      TL-WN725N). Dazu musste ich den hostapd (/usr/sbin/hostapd) austauschen
      gegen den von <a href="http://dl.dropbox.com/u/1663660/hostapd/hostapd.zip">http://dl.dropbox.com/u/1663660/hostapd/hostapd.zip</a>.
      Der originale ist noch als hostapd.ori vorhanden – also ggf. wieder
      umbennen. Anpassungen zur Konfiguration muss man in
      /etc/hostapd/hostapd.conf vornehmen. In jedem Falle sollte hier der
      WPA-Key getauscht werden (standard: SSID avnav, pw: avnav-secret). Ggf.
      muss man den driver ändern. Danach service hostapd restart und die
      WLAN-Verbindung testen. Eine gute Anleitung findet sich unter <a href="http://elinux.org/RPI-Wireless-Hotspot">http://elinux.org/RPI-Wireless-Hotspot</a>.</p>
    <p>Das WLAN hat den Adressbereich 192.168.20.0/24. Der pi selbst ist auf
      192.168.20.10 erreichbar (ggf. als url im Browser benutzen, wenn die
      Namensauflösung nicht funktioniert). Auf dem pi läuft ein DHCP server und
      ein DNS server (dnsmasqd). Die Konfiguration kann angepasst werden in
      /etc/dnsmasqd.conf. Wenn der pi im LAN angeschlossen ist, versucht er per
      DHCP eine Adresse zu bekommen, das WLAN wird per NAT an das LAN interface
      weitergereicht (damit kann man den pi ins Internet bringen - z.B. zum
      Installieren von Software- und auch per Wlan verbundene Geräte haben dann
      Internet-Zugriff). </p>
    <p>Für die Auslieferung einiger Karten ist der lighthttpd installiert.
      Dieser kann gff. Auch für weitere Funktionen genutzt werden. Er ist jedoch
      per default auf port 81 aufgesetzt. Port 80 ist direkt zum Web server von
      avnav weitergeleitet (dieser lauscht auf port 8080).</p>
    <p>Wenn alles richtig aufgesetzt ist, sollte sich unter der url <a href="http://avnav/">http://avnav</a>
      die Einstiegsseite der WebApp öffnen.</p>
    <p>Mit <em>sudo service avnav status</em> kann man den Status des servers
      prüfen, mit <em>sudo service avnav start</em> bzw. <em>sudo service
        avnav stop</em> kann man ihn starten und stoppen.</p>
    <h3 class="western">Installation mit „stock image“</h3>
    <p>(Danke an Christian für ein paar Hilfestellungen) Hierbei zunächst das
      debian wheezy image von <a href="http://www.raspberrypi.org/downloads">http://www.raspberrypi.org/downloads</a>
      installieren (Anleitung siehe dort). Danach muss man eine Reihe weiterer
      Pakete installieren, die Konfigurationen vornehmen und zum Schluss die
      avnav software installieren. Nach dem ersten reboot Übertakten auf 1GHz
      einstellen.<br>
      Hier eine kurze Dokumentation der Schritte (ohne ganz detaillierte
      Beschreibung):</p>
    <ul>
      <li>
        <p>gpsd<br>
          <a href="http://blog.retep.org/2012/06/18/getting-gps-to-work-on-a-raspberry-pi/">http://blog.retep.org/2012/06/18/getting-gps-to-work-on-a-raspberry-pi/</a><br>
          sudo apt-get install gpsd gpsd-clients python-gps</p>
      </li>
      <li>
        <p>bluetooth<br>
          <a href="http://www.rpiblog.com/2012/08/bluetooth-pairing-of-raspberry-pi-with.html">http://www.rpiblog.com/2012/08/bluetooth-pairing-of-raspberry-pi-with.html</a><br>
          apt-get install -y bluetooth [bluez-utils blueman]</p>
      </li>
      <li>
        <p>pyserial<br>
          copy pyserial to pi (<a href="https://pypi.python.org/packages/source/p/pyserial/pyserial-2.6.tar.gz#md5=cde799970b7c1ce1f7d6e9ceebe64c98">https://pypi.python.org/packages/source/p/pyserial/pyserial-2.6.tar.gz#md5=cde799970b7c1ce1f7d6e9ceebe64c98</a>)<br>
          unpack tar -xvzf …<br>
          cd into pyserial dir<br>
          python setup.py install</p>
      </li>
      <li>
        <p> python bluetooth support<br>
          sudo apt-get install python-bluez</p>
      </li>
      <li>
        <p>python udev support<br>
          sudo apt-get install python-pyudev</p>
      </li>
      <li>
        <p>hotspot - see <a href="http://elinux.org/RPI-Wireless-Hotspot">http://elinux.org/RPI-Wireless-Hotspot</a><br>
          sudo apt-get install hostapd dnsmasqd<br>
          we use 192.168.20.00 for our wireless setup<br>
          20...254 - dhcp raspi<br>
          10 - raspi itself</p>
      </li>
      <li>
        <p>etc/hosts<br>
          192.168.20.10 avnav</p>
      </li>
      <li>
        <p>/etc/dnsmasqd.conf<br>
          interface=wlan0<br>
          domain=avnav<br>
          dhcp-range=192.168.20.20,192.168.20.254,255.255.255.0,12h<br>
          dhcp-option=42,0.0.0.0<br>
          expand-hosts<br>
          dhcp-option=6,192.168.20.10</p>
      </li>
      <li>
        <p>natting<br>
          /etc/sysctl.conf: net.ipv4.ip_forward=1<br>
          iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE<br>
          iptables -A FORWARD -i eth0 -o wlan0 -m state --state
          RELATED,ESTABLISHED -j ACCEPT<br>
          iptables -A FORWARD -i wlan0 -o eth0 -j ACCEPT<br>
          iptables-save &gt; /etc/iptables.ipv4.nat</p>
      </li>
      <li>
        <p>/etc/network/interfaces<br>
          auto lo<br>
          iface lo inet loopback<br>
          iface eth0 inet dhcp<br>
          allow-hotplug wlan0<br>
          iface wlan0 inet static<br>
          address 192.168.20.10<br>
          netmask 255.255.255.0<br>
          up iptables-restore &lt; /etc/iptables.ipv4.nat</p>
      </li>
      <li>
        <p>/etc/hostapd/hostapd.conf<br>
          interface=wlan0<br>
          #driver=nl80211 #original value <br>
          driver=rtl8192cu<br>
          ssid=avnav<br>
          hw_mode=g<br>
          channel=6<br>
          macaddr_acl=0<br>
          auth_algs=1<br>
          ignore_broadcast_ssid=0<br>
          wpa=2<br>
          wpa_passphrase=avnav-secret<br>
          wpa_key_mgmt=WPA-PSK<br>
          wpa_pairwise=TKIP<br>
          rsn_pairwise=CCMP</p>
      </li>
      <li>
        <p>/etc/default/hostapd<br>
          DAEMON_CONF="/etc/hostapd/hostapd.conf"</p>
      </li>
      <li>
        <p>check hostapd (see avnav image)</p>
      </li>
      <li>
        <p>set up ntp sync<br>
          see <a href="http://catb.org/gpsd/gpsd.html">http://catb.org/gpsd/gpsd.html</a><br>
          -- does not work out of the box<br>
          as gpsd is running non root, we have to enable other SHM segments!<br>
          /etc/ntp.conf:<br>
          server 127.127.28.0<br>
          fudge 127.127.28.0 time1 0.420 refid GPS<br>
          server 127.127.28.1 prefer<br>
          fudge 127.127.28.1 refid GPS1<br>
          server 127.127.28.2<br>
          fudge 127.127.28.2 time1 0.420 refid GPS2<br>
          server 127.127.28.3 prefer<br>
          fudge 127.127.28.3 refid GPS3</p>
      </li>
      <li>
        <p>prevent pi from interacting on boot due to corrupted FS<br>
          see <a href="http://www.raspberrypi.org/phpBB3/viewtopic.php?f=28&amp;t=15870">http://www.raspberrypi.org/phpBB3/viewtopic.php?f=28&amp;t=15870</a><br>
          sudo vi /etc/default/rcS<br>
          change #FSCKFIX=no<br>
          to FSCKFIX=yes</p>
      </li>
      <li>
        <p>lighthttpd for faster chart delivery<br>
          apt-get update<br>
          apt-get install lighttpd<br>
          first shot: configure to port 81 (so that our redirect from 80 to 8080
          can remain...):<br>
          /etc/lighttpd/lighttpd.conf:<br>
          server.port = 81<br>
          alias.url = ( "/charts" =&gt; "/data/avnav/charts/" )</p>
      </li>
      <li>enable port forwarding of port 80 to 8080 <br>
        in /etc/defaults/avnav:<br>
        FORWARD=8080 </li>
      <li>bluetooth workaround<br>
        bluetoothd crashes on btd-122<br>
        in /etc/default/avnav:<br>
        HCIDEVICES="hci0 hci1 hci2 hci3 hci4"<br>
        started diese devices wenn avnav started<br>
      </li>
      <li>nstall avnav<br>
        Herunterladen der aktuellen Software von <a href="http://www.wellenvogel.de/software/avnav/download">wellenvogel.de</a>.
        Auspacken des archives als pi im Verzeichnis /home/pi/avnav. Danach
        Aufruf (als root) ./setup.sh part </li>
      <li>checken service avnav status. </li>
    </ul>
    <p><br>
      <br>
    </p>
    <h2 class="western"><a name="Chartconvert">Konvertieren der Karten</a></h2>
    <p>Damit Karten in der WebApp verwendet werden können, müssen sie in einem
      „Kachelformat“ vorliegen. Das ist das Format, das durch Dienste wie
      OpenStreetMaps oder GoogleMaps benutzt wird. Eine Kartenkachel ist 256x256
      Pixel gross. Die Welt wird dabei auf eine ebene Fläche projeziert (kann
      man sich das wie einen Papierzylinder vorstellen, der senkrecht steht und
      am Äquator um die Erde gewickelt wird). Jeder Punkt mit seinen Koordinaten
      (Länge/Breite) wird dann auf diesen Zylinder projeziert. Wie man das
      macht, welche Einheiten in der Projektion verwendet werden und ob die Erde
      als Kugel oder Ellipsoid mit verschiedenen Parametern modelliert wird,
      beschreiben die verschiedenen Projektionen. Die WebApp benutzt die
      sogenannte Google-Mercator Projektion (die Erde wird dabei als Kugel
      betrachtet) - mit dem EPSG code 900913. Die Einheiten auf dem Papier sind
      dabei Meter (die man natürlich in die entsprechenden Koordinaten umrechnen
      kann). Karten in einem anderen Format (z.B. WGS84 – Erde als Ellipsoid,
      immer in Grad) müssen daher ggf. reprojeziert werden. </p>
    <p>Die gesamte Projektionsfläche wird bei der google Projektion in Kacheln
      unterteilt. Der Zoom level gibt an, in wieviele Kacheln die Fläche
      unterteil wird. Zoom level 0 bedeuted: Die gesamte Erde (von -85° bis +85°
      Breite – darüber ist die Projektion nicht definiert) auf einer Kachel von
      256x256 Pixel. Mit jedem weiteren ZoomLevel wird feiner unterteilt: Zoom
      level 1: 2x2 Kacheln, 2: 4x4 Kacheln usw. Für uns reichen die
      interessanten Zoom Level von ca. 7 bis 18..19. Das bedeutet (level 19)
      2^19x2^19 Kacheln.</p>
    <p>Zur Darstellung wird die library <a href="http://www.openlayers.org/">openlayers</a>
      verwendet. Diese lädt die entsprchenden Kartenkacheln je nach zoom level
      vom raspberry und zeigt sie an. OpenStreetMaps verwendet typischerweise
      diese Library.</p>
    <p>Man kann sich leicht vorstellen, das bei hohen Zoomleveln schnell große
      Datenmengen zusammenkommen. Daher müssen wir für unsere Kartenkacheln
      ähnlich vorgehen, wie es auch bei den Papierkarten ist: Für Übersichten
      ein kleinerer Zoom Level, Detailkarten größer und z.B. Hafenpläne dann mit
      level 18 oder 19 (60cm/pixel bzw. 30cm/pixel). Um damit arbeiten zu
      können, werden die verschiedenen Detailgrade dann in Layern (Schichten)
      übereinandergelegt. Wenn es für ein Gebiet einen Layer mit besserem
      (grösserem) zoomlevel gibt, wird dieser angezeigt, wenn nicht, der mit der
      geringeren Auflösung (ggf. noch vergrössert). Um unsere Anzeigegeräte
      nicht zu überlasten, kann man typisch mit 3-5 Kartenlayern arbeiten (je
      nach Gerät...).</p>
    <p>Damit besteht für die Kartenkonvertierung die Aufgabe darin, vorhandene
      Karten in solche Layer einzusortieren, sie ggf zu reprojezieren und dann
      die Kartenkacheln (sowie eine Beschreibungsdatei) zu erzeugen. Das
      erfordert meist eine ganze Menge Rechenleistung (und ggf. Zeit), daher ist
      das etwas, dass auf einem PC oder Laptop laufen sollte (der pi ist dafür
      zu schwach). Das ist aber nicht schlimm – man muss das ja nur einmal
      machen. Belohnt wird man dafür mit einer sogenannten „blattschnittfreien“
      Darstellung.</p>
    <p>Das Verfahren dazu hängt von der Quelle ab. Im Moment habe ich support
      für 2 „Wege“ der Kartenerstellung eingebaut:</p>
    <ul>
      <li>
        <p>Konvertierung von Karten mittels <a href="http://www.gdal.org/">GDAL</a>
          (z.B. BSB) – hier kann alles gelesen werden, was gdal kann</p>
      </li>
      <li> Nutzung von downloads mit dem <a href="http://mobac.sourceforge.net/">Mobile
          Atlas Creator</a>. </li>
    </ul>
    <p>Ab der Version 2014-03-21 können die Karten in das <a href="http://www.cgtk.co.uk/gemf">GEMF</a>
      Format konvertiert werden - das ist ein kompaktes Format - anstelle von
      sehr vielen einzelnen Files sind diese in einem großen File
      zusammengefaßt. </p>
    <p>Achtung: die folgende Beschreibung bezieht sich auf diese Version -
      ältere Server-Versionen können mit der GEMF Datei nichts anfangen.</p>
    <h3 class="western">Konvertierung von Karten mit GDAL</h3>
    <p>Für diese Konvertierung müssen einige Tools installiert werden. Das ist
      zwar leider ein wenig Aufwand, muss aber nur einmalig erledigt werden. </p>
    <p>Zunächst wird python (ab 2.6) benötigt. Für Windows (64 Bit) z.B. von <a
        href="http://www.python.org/ftp/python/2.7.3/python-2.7.3.amd64.msi">http://www.python.org/ftp/python/2.7.3/python-2.7.3.amd64.msi</a>
      . </p>
    <p>Danach GDAL und GDAL python bindings (http://www.gisinternals.com/sdk/ -
      <a href="http://www.gisinternals.com/sdk/PackageList.aspx?file=release-1600-x64-gdal-1-9-2-mapserver-6-2-0.zip">http://www.gisinternals.com/sdk/PackageList.aspx?file=release-1600-x64-gdal-1-9-2-mapserver-6-2-0.zip</a>,
      <a href="http://www.gisinternals.com/sdk/Download.aspx?file=release-1600-x64-gdal-1-9-2-mapserver-6-2-0">http://www.gisinternals.com/sdk/Download.aspx?file=release-1600-x64-gdal-1-9-2-mapserver-6-2-0</a>\gdal-19-1600-x64-core.msi,
      <a href="http://www.gisinternals.com/sdk/Download.aspx?file=release-1600-x64-gdal-1-9-2-mapserver-6-2-0">http://www.gisinternals.com/sdk/Download.aspx?file=release-1600-x64-gdal-1-9-2-mapserver-6-2-0</a>\GDAL-1.9.2.win-amd64-py2.7.msi
).
      Anschliessend GDAL_DATA im environment setzen und GDAL in den Pfad
      aufnehmen. </p>
    <p>Dazu noch PIL für python ( <a href="http://www.lfd.uci.edu/%7Egohlke/pythonlibs/">http://www.lfd.uci.edu/~gohlke/pythonlibs/</a>).</p>
    <p>Der Hauptteil der Konvertierung wird durch tiler_tools durchgeführt (<a href="https://code.google.com/p/tilers-tools/">https://code.google.com/p/tilers-tools/</a>)
      diese sind Bestandteil der Software und müssen nicht extra heruntergeladen
      werden.. </p>
    <p>Von der <a href="http://www.wellenvogel.net/software/avnav/downloads/index.php">download
        Seite</a> sollte die xxx-host.zip Datei heruntergeladen und in einem
      beliebigen Verzeichnis entpackt werden.</p>
    <p>Für OSX und Windows (getestet unter Windows 7) sind jeweils minimale GUIs
      vorhanden, die es erlauben die Konvertierung zu starten sowie zum Test der
      erzeugten Karten die Server-Software.</p>
    <p>Die Karten werden per default im Verzeichnis
      &lt;UserHome&gt;/AvNavCharts/out erzeugt (also z.B.
      c:\Users\Andreas\AvNavCharts\out). Zumindest in der Windows GUI kann das
      Verzeichnis gewählt werden. Standarmäßig ensteht für jeden Konverter-Lauf
      eine xxx.gemf Datei, xxx ist dabei der Dateiname der ersten Datei oder der
      Name des ersten gewählten Verzeichnisses.</p>
    <p><img src="gui-windows2.PNG" height="642" width="653"></p>
    <p>Im Bild ist die Windows GUI zu sehen - start im windows-Verzeichnis -
      AvChartConvert. Oben können die zu konvertierenden Karten gewählt werden,
      unten das Ausgabe-Verzeichnis. Mit den gezeigten Einstellungen wird eine
      einzelne Karten umgewandelt, nach der Umwandlung wird der Server gestartet
      (port 8080). Den kann man dann im Browser mit <a href="http://127.0.0.1:8080">http://127.0.0.1:8080</a>
      erreichen.</p>
    <p>Unter OSX lann der Konverter durch Klick auf AvChartConvert im osx
      Verzeichnis gestartet werden (ggf. ins Dock legen für drag &amp; drop),
      der Server durch Klick auf avnav.command.</p>
    <p>Unter Linux gibt es ebenfalls eine minimale grafische Oberfläche - sie
      erfordert wxPython (python-wxgtk2.8). Zum Starten im linux Verzeichnis
      avnav_gui.py aufrufen (python-gdal muss installiert sein). Linux getestet
      unter Ubuntu 14.04.</p>
    <p>Im AvNavCharts Verzeichnis gibt es auch noch ein work-Verzeichnis, dieses
      sollte nicht gelöscht werden, da dann bei einem Update (z.B.
      Berichtigungen eingepflegt) nur die geänderten Karten neu erzeugt werden
      müssen.</p>
    <p>Die Konvertierung verläuft in 2 Schritten:</p>
    <ul>
      <li>
        <p>Sortierung der Karten in layer (und ggf. soweit nötig Konvertierung
          der karten). </p>
      </li>
      <li>
        <p>Erzeugung der Kacheln</p>
      </li>
    </ul>
    <p>Wenn die Datei xxx.gemf rezeugt wurde, diese auf den raspberry nach
      /data/avnav/charts kopieren (darauf achten, dass sie für den Nutzer pi
      lesbar ist). Der Server sollte sie automatisch erkennen...</p>
    <p>Im Folgenden werden die Konvertierungsschritte beschrieben -
      normalerweise muss man sich darum nicht kümmern - nur wenn die
      default-Einstellungen der GUI nicht gut genug sind...</p>
    <blockquote>
      <div style="font-size:small">
        <p>Der erste Schritt geht relativ schnell. Alle Kartendateien werden
          gelesen und Auflösung und Abdeckung wird ermittelt (falls nötig wird
          konvertiert). Im Ergebnis entsteht im workdir/&lt;name&gt; Verzeichnis
          eine Datei chartlist.xml. Der Aufruf dazu lautet:</p>
        <pre>read_charts.py -o name -m chartlist inputdir [inputdir...]
</pre>
        <p>Anschliessend sollte die chartlist.xml noch einmal mit einem
          Texteditor überprüft werden, manchmal macht es Sinn, Kartendateien
          noch einem anderen Layer zuzuordnen. Das kann einfach durch
          Verschieben des entsprechenden XML Elements erfolgen. Man kann sich
          dazu an den Namen der Karten orientieren - meist mach es Sinn Karten
          vergleichbaren Detailgrades in einen Layer zu verschieben.</p>
        <p>Der zweite Schritt ist etwas langwieriger, hier erfolgt die
          eigentliche Erzeugung der Kartenkacheln. Der Aufruf:</p>
        <pre>read_charts.py -o name -m generate 
</pre>
        <p> Unter workdir/&lt;name&gt; muss bereits eine chartlist.xml
          existieren. Die Erzeugung läuft multi-threaded, auf einem Dual Core
          2x2Ghz ca. 20 min für einen Kartensatz mit ca. 20 Karten. </p>
        <p>Man kann auch beide Schritte kombinieren – dazu einfach -m all noch
          vor den anderen Parametern bei Schritt 1 angeben:</p>
        <blockquote>
          <pre>read_charts.py -m all [-o name] inputdir
</pre> </blockquote>
      </div>
    </blockquote>
    <h3 class="western">Nutzung von Karten mit dem Mobile Atlas Creator</h3>
    <p>Für die Nutzung des Mobile Atlas Creators ist keine weitere Software auf
      dem PC/Laptop nötig. Man muss beim Download der Karten allerdings ein
      gewisses Schema einhalten, damit die Karten in das oben beschriebene
      Layer-Konzept passen und die Datenmengen überschaubar bleiben. </p>
    <p>Dazu sollte man (je nach Kartenquelle) z.B. 3 Layer vorsehen: Übersicht(
      Zoom Level 7-10) Navigation (level 10-15), Details (Level 16-18).
      Anschliessend sollte man im MOBAC layerweise vorgehen. Dazu jeweils als
      gewünschte Zoomlevel die zum Layer gehörigen anklicken (links oben),
      danach alle Teilbereiche jeweils markieren und unter einem beliebigen
      Namen dem Atlas hinzufügen. Das jeweils für die anderen Layer wiederholen
      (dabei sinnvolle Auswahlen treffen). Anschliessend sollte man die
      Atlas-Konfiguration unter einem beliebigen Namen speichern - die kann man
      ggf. nochg für weitere Versuche brauchen. Als output Format OsmDroid GEMF
      (File-&gt;convertAtlasFormat) wählen und die Atlas-Erzeugung starten. Im
      output Verzeichnis entsteht eine xxx.gemf Datei. Diese auf den raspberry
      unter /data/avnav/charts kopieren. Ab der Version avnav-2014-04-08 ist das
      ausreichend, bei älteren Versionen muss man noch Folgendes tun:<br>
      Den Atlas speichern (Profil speichern). Diese Datei (liegt im
      Programmverzeichnis von MOBAC) in das gleiche Verzeichnis kopieren und zu
      xxx.xml umbenennen (wichtig!).</p>
    <p>Auf der <a href="http://www.wellenvogel.net/software/avnav/downloads/index.php">download
        Seite</a> sammle ich chart sources für den mobac, die für uns nützlich
      sein lönnten. </p>
    <h2>Die Web App</h2>
    Zur Navigation mit den auf dem Raspberry Pi vorhandenen Karten gibt es eine
    Web App.<br>
    Die App kommuniziert mit dem webserver des avnav_server.py auf dem pi. Die
    Einstiegsseite ist unter der url <a href="http://avnav/viewer/avnav_viewer.html">http://avnav/viewer/avnav_viewer.html</a>
    erreichbar. Es is eine sogenannte „single page app“, d.h. Die weitere
    Kommunikation mit dem server geschieht per Ajax durch den JavaScript Anteil.
    Vom Layout ist sie optimiert für die Darstellung auf einem 7 Zoll Tablet
    (bei mir momentan im Einsatz: Nexus 7 am Navitisch, Blackberry Playbook
    draussen), sie läuft aber natürlich auch auf größeren Tablets (Ipad) oder
    auf einem Laptop/Desktop. Eine sinnvolle Nutzung ist ab etwa 900x540 Pixel
    möglich.<br>
    <br>
    Zur Beschreibung der WebApp <a href="avnav-de.html">hier</a>.<br>
  </body>
</html>
