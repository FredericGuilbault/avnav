<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
	<TITLE></TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice.org 3.4.1  (Unix)">
	<META NAME="CREATED" CONTENT="20130720;22180300">
	<META NAME="CHANGED" CONTENT="20130729;17353700">
	<STYLE TYPE="text/css">
	<!--
		H2.ctl { font-family: "Arial Unicode MS" }
		H3.ctl { font-family: "Arial Unicode MS" }
		H4.ctl { font-family: "Arial Unicode MS" }
	-->
	</STYLE>
</HEAD>
<BODY LANG="de-DE" DIR="LTR" style="max-width: 650px">
<H1>Raspberry Pi als Bordcomputer / Navigation im Browser	</H1>
<P>15.10.2013</P>
<P><BR>
</P>
<H2 CLASS="western">Motivation</H2>
<P>Nachdem ich schon eine ganze Weile mit Rasterkarten unterwegs
navigiere (erst unter Windows mit Seaclear, dann unter Windows,
WindowsCE und OSX mit OpenCPN und OziExplorer) hatte ich schon eine
ganze Weile nach Möglichkeiten gesucht, das zu erweitern und noch
besser tauglich für unterwegs zu machen.</P>
<P>Meine Wunschliste dabei war:</P>
<UL>
	<LI><P>Navigation auf  kleinen Geräten (Laptop ist immer ein wenig
	unhandlich) – 7 oder 10 Zoll Tablet wäre Ideal</P>
	<LI><P>Navigation auch im Cockpit</P>
	<LI><P>Trackaufzeichnung</P>
	<LI><P>Verknüpfung mit der „on board“ Navigation (seit einiger
	Zeit habe ich ein RO4800 als Funke, das auch einen AIS Decoder hat –
	und ja auch schon GPS Daten bekommt)</P>
	<LI><P>Nutzung der Rasterkarten (BSB, NV, alles was sich per
	Download über mobile atlas creator bekommen lässt...)</P>
	<LI><P>Minimaler Installationsaufwand</P>
	<LI><P>Klein, wenig Stromverbrauch (sollte möglichst immer laufen
	können)</P>
	<LI><P>Wenig „Bastelarbeit“ - also möglichst keine eigenen
	Schaltungen löten</P>
</UL>
<P>Irgendwann habe ich mal den raspberry pi entdeckt und nachdem er
zu Hause jetzt schon eine Weile als media center arbeitet, dachte
ich, dass der eine gute Basis für einen Bordcomputer abgeben könnte.
</P>
<P>Allerdings musste ich nach einiger Recherche feststellen, dass es
noch keine fertige Software gab, die meinen Anforderungen genügen
würde. Insbesondere die Einbettung der seriellen Schnittstellen
(typisch seriell-usb-Wandler) macht immer wieder Mühe, da Linux hier
immer etwas kreativ ist... 
</P>
<P>Also habe ich beschlossen mich selbst daran zu machen. Im
Folgenden will ich meine Lösung beschreiben, da es ja vielleicht
Interessierte gibt, die es Nachnutzen möchten. Die gesamte Software
steht zum download unter einer open source Lizenz bereit. 
</P>
<P><BR><BR>
</P>
<H2 CLASS="western">Überblick 
</H2>
<P><IMG SRC="overview.png" NAME="Grafik1" ALIGN=LEFT WIDTH="600" BORDER=0><BR CLEAR=LEFT>Wie
im Bild zu sehen, besteht die gesamte Lösung aus mehreren Teilen:</P>
<UL>
	<LI><P>Einem Raspberry Pi mit einer server software
	(avnav_server.py), die die angeschlossenen Geräte (NMEA über
	Seriell-USB Wandler – z.B. PL 2303), Bluetooth GPS,... abfragt,
	die Daten aufbereitet und per WLAN zur Verfügung stellt</P>
	<LI><P>Einer Software für Windows/OSx/Linux, die zum Vorbereiten
	und Konvertieren der Karten dient</P>
</UL>
<P>Über ein WLAN, das der raspberry pi als access point
bereitstellt, können verschiedene Geräte auf die Daten zugreifen.
Dabei gibt es mehrere Varianten:</P>
<UL>
	<LI><P>Auf den Geräten (z.B. Ipad oder Laptop) kann eine
	Navigationssoftware laufen (getestet: InavX,OpenCPN), diese greifen
	über TCP auf die NMEA Daten zu. Navigationssoftware und Karten
	müssen natürlich auf den Geräten installiert sein.</P>
	<LI><P>Auf den Geräten läuft nur ein Browser, die Navigation
	erfolgt per Java Script app, die vom raspberry bereitgestellt wird.
	Dazu muss nur die entsprechende URL aufgerufen werden. In diesem
	Falle ist auf den Geräten keine Software installiert, nur ein
	aktueller Browser muss vorhanden sein (getestet: Chrome unter
	Windows, OSX, Safari, Android ab 4.x – Chrom/Stock/Boat Browser,
	IOS, Blackberry stockBrowser, WebBrowser mini).</P>
</UL>
<P>Die server software auf dem raspberry ist in python geschrieben
und über ein xml file konfigurierbar (was im Normalfall aber nicht
notwendig sein sollte). Ich stelle neben dieser Software auch ein
fertiges Image für den raspberry zur Verfügung, dass nur noch auf
eine SD-Karte installiert werden muss (Empfehlung: mindestens 8GB,
mehr ist besser...).</P>
<P>Die Web Applikation bietet eine (bisher recht simple) Navigation
mit Rasterkarten inklusive AIS Darstellung. Falls die Web-Applikation
verwendet werden soll, müssen die Karten dafür auch auf dem
raspberry installiert werden. Diese müssen dazu vorher auf dem PC
(Windows, Osx, Linux) konvertiert werden. Im Wesentlichen können die
folgenden Kartenquellen verarbeitet werden:</P>
<UL>
	<LI><P>Alle Kartentypen, die die GDAL software lesen kann (also
	insbesondere BSB Karten)</P>
	<LI><P>Mit Mobile Atlas Creator heruntergeladene Karten</P>
	<LI><P>Zur Nutzung von NV digital Karten bitte ich um
	Kontaktaufnahme, hier ist die Einhaltung der Lizenzbedingungen ein
	Thema.</P>
</UL>
<P>In den folgenden Abschnitten gehe ich auf die Funktion der
einzelnen Teile ein wenig genauer ein.</P>
<P><BR><BR>
</P>
<H2 CLASS="western">Die Server Software (avnav_server.py)</H2>
<P>Auf dem raspberry pi ist zunächst ein<a href="http://www.raspberrypi.org/downloads"> ganz normales Debian image</a> installiert (ca. 2GB). Dazu kommen einige Zusatzpakete (liste siehe
unten) und meine Software. </P>
<P>Der Hauptbestandteil der Sofware auf dem raspberry pi ist ein in
python geschriebener Server. Im Folgenden beschreibe ich in groben Zügen, was dieser Server intern tut.</P>
<P><IMG SRC="software.png" NAME="Grafik2" ALIGN=LEFT WIDTH=600  BORDER=0><BR CLEAR=LEFT><BR><BR>
</P>
<P>Dieser Server versucht alle am raspberry angeschlossenen seriellen
Geräte zu erkennen und deren NMEA Daten zu lesen. Typisch werden die
Geräte über seriell-usb Wandler angeschlossen (bei mir z.B.
PL2303). Man muss ein wenig aufpassen, dass man einen Wandler hat,
der vom Raspberry auch sauber unterstützt wird - siehe z.B. <a href="http://elinux.org/RPi_VerifiedPeripherals#USB_UART_and_USB_to_Serial_.28RS-232.29_adapters">hier</a>. Da das
Verwalten der seriellen Schnittstellen unter Linux etwas magisch ist,
scant der Server (per Dbus) die angeschlossenen Geräte auf eine
entsprechende serielle Klasse und ermittelt deren Schnittstelle
(device). Anschliessend versucht er ein auto bauding zwischen 4800
und 34000 Baud und bemüht sich, NMEA Daten zu erkennen. Falls keine
Daten empfangen werden, wird die Schnittstelle geschlossen und das
Spiel beginnt von vorn. Damit „überlebt“ er auch das
anschliessen/abstecken von Wandlern im Betrieb oder das An- bzw.
Abschalten von Geräten. Bei mir hängt ein RO4800 mit AIS Decoder
dran, die GPS Daten werden durchgereicht. Alternativ versucht er auch
Kontakt zu seriellen Bluetooth Geräten aufzunehmen, falls er per
discovery welche findet und versucht ebenfalls NMEA Daten zu Lesen.
Getestet bei mir mit einer Holux GPS Slim236. In diesem Sinne
arbeitet er auch als NMEA Multiplexer.</P>
<P>Alle GPS-Daten werden intern in eine Liste eingefügt und per TCP bereitgestellt. Verbundene TCP Empfänger (z.B. OpenCPN) bekommen so jeden 
empfangenen Datensatz  weitergereicht. Per
Default &quot;lauscht&quot; der server (intern:SocketWriter) auf Port 34567.</P>
<P>Anschliessend werden die NMEA Daten an den Decoder weitergereicht.
Auf dem raspberry benutze ich dazu <a href="http://catb.org/gpsd/">gpsd</a>. Leider liess der sich nicht
verwenden, um direkt die seriellen Schnittstellen zu lesen, daher
macht der avnnav_server einen Socket auf, an den sich der gpsd
connected und von dem er die Daten liest. Das Starten des gpsd
übernimmt ebenfalls der anav server. Am „anderen Ende“ werden
über die gpsd python Schnittstelle die dekodierten Daten ausgelesen
(gps Daten und AIS Daten) und im Server abgelegt (&quot;NMEA decoded data&quot;) für den Zugriff per
HTTP aus der WebApp. Der gpsd wird überwacht und bei Fehlern neu
gestartet. Zusätzlich werden die dekodierten Daten auch benutzt um
Track Dateien zu schreiben.</P>
<P>Über den integrierten WebServer kann der Zugriff auf diese
dekodierten Daten erfolgen (per HTTP GET, Antwort als json).</P>
<P>Falls gültige GPS Zeitinformationen empfangen werden, wird die
Systemzeit des raspberry entsprechend eingestellt.</P>
<P>Auf dem raspberry gibt es noch einen service, der den avnav_server
beim Systemstart automatisch startet und es auch ermöglicht, ihn
geordnet zu beenden.</P>
<P>Da der gesamte server in python geschrieben ist, kann er auch (vor
allem zu Testzwecken) unter Windows oder Osx (Mac), Linux laufen. Dazu muss
python ab 2.6 installiert sein,  falls reale serielle Daten gelesen
werden sollen noch <a href="http://pyserial.sourceforge.net/">pyserial</a>. In diesem Falle steht gpsd als Dekoder
ja nicht zur Verfügung, es wird dann ein interner Dekoder genutzt,
der die wichtigsten NMEA Sequenzen dekodiert und ein AIS Dekoder in
python, der ebenfalls durch das gpsd Projekt bereitgestellt wird.</P>
<P>Der Server kann in weiten Grenzen durch ein xml File konfiguriert
werden, für die verschiedenen Nutzungsfälle liefere ich
dokumentierte Beispiele mit.</P>
<P>In der Auslieferung für den pi ist die Software so konfiguriert, dass sie alle per USB angebundenen seriellen Schnittstellen öffnet, dort versucht NMEA DAten zu erkennen (per auto-bauding von 4800 B/s bis 38400 B/s) und diese dann verarbeitet. Wenn eine gültige Uhrzeit erkannt wird, wird die Systemzeit gesetzt. Ausserdem wird (falls ein Bluetooth adapter erkannt wurde) versucht, mit allen seriellen Bluetooth Geräten Verbindung aufzunehmen und auch von dort NMEA Daten zu empfangen. Damit sollte im Normalfall keine weitere Konfiguration nötig sein und NMEA Daten sofort erkannt werden (kann man im Status display prüfen - s.u.).</P>
<H2 CLASS="western">Software auf dem raspberry</H2>
<P>Auf dem raspberry ist die Software in der folgenden
Verzeichnisstruktur installiert:</P>
<TABLE WIDTH=100% BORDER=1 CELLPADDING=4 CELLSPACING=4>
	<COL WIDTH=73*>
	<COL WIDTH=183*>
	<TR VALIGN=TOP>
		<TH WIDTH=28%>
			<P>Verzeichnis</P>
		</TH>
		<TH WIDTH=72%>
			<P>Inhalt</P>
		</TH>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=28%>
			<P>/data/</P>
		</TD>
		<TD WIDTH=72%>
			<P>Eine separate data partition. Diese wird automatisch beim
			ersten Hochfahren angelegt und umfasst die gesamte Speicherkarte
			(- ca. 2GB für die boot partition und die root partition). Das
			Filesystem ist so angelegt, dass es gut mit sehr vielen kleinen
			Dateien umgehen kann (für die Karten).</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=28%>
			<P>/data/avnav/charts</P>
		</TD>
		<TD WIDTH=72%>
			<P>Verzeichnis für die Kartendateien. Jeder verwendete Kartensatz
			muss in einem separaten Unterverzeichnis liegen. Dort hinein
			müssen jeweils die avnav.xml und die erzeugten
			Kartenverzeichnisse kopiert werden (siehe<a href="#Chartconvert"> Karten konvertieren</a>).</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=28%>
			<P>/dava/avnav/log</P>
		</TD>
		<TD WIDTH=72%>
			<P>logfiles</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=28%>
			<P>/data/avnav/tracks</P>
		</TD>
		<TD WIDTH=72%>
			<P>Die trackfiles. Sie werden in einem File pro Tag gespeichert.
			Momentan ist das ein simples csv Format, eine Konvertierung nach
			gpx steht schon auf der todo Liste.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=28%>
			<P>/home/pi/avnav/data</P>
		</TD>
		<TD WIDTH=72%>
			<P>Links zu /data/avnav/charts, /data/avnav/tracks,
			/data/avnav/log. Ausserdem die config Datei avnav_server.xml. Beim
			ersten Start wird sie dorthin kopiert, danach aber nicht wieder
			überschrieben. Etwaige Anpassungen also hier.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=28%>
			<P>/home/pi/avnav/setup.sh</P>
		</TD>
		<TD WIDTH=72%>
			<P>Kann als root aufgerufen werden, um ein update der Software zu
			machen (bei Internet-Verbindung):<BR>setup.sh update &lt;url&gt;</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=28%>
			<P>/home/pi/avnav/program</P>
		</TD>
		<TD WIDTH=72%>
			<P>Das Program-Verzeichnis.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=28%>
			<P>/home/pi/avnav/program/server</P>
		</TD>
		<TD WIDTH=72%>
			<P>Der eigentliche server: avnav_server.py, <BR>Der ais Dekoder
			(aus dem gpsd Projekt): ais.py, <BR>Konvertierung von MOBAC atlas
			files zu avnav.xml: create_overview.py</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=28%>
			<P>/home/pi/avnav/program/raspberry</P>
		</TD>
		<TD WIDTH=72%>
			<P>Raspberry spezifische software Anteile (u.a. der service zum
			Starten von avnav_server)</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=28%>
			<P>/home/pi/avnav/program/libraries</P>
		</TD>
		<TD WIDTH=72%>
			<P>Die verwendeten JS libraries für die WebApp.<BR>Das sind:<BR>*
			  <a href="http://www.openlayers.org/">OpenLayers</a><BR>* <a href="http://jquery.com/">jQuery</a><BR>* <a href="http://lesscss.org/">less</a><BR>* <a href="http://www.movable-type.co.uk/scripts/latlong.html">movable-type</a> (java script
			functions von movable type)</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=28%>
			<P>/home/pi/avnav/program/viewer</P>
		</TD>
		<TD WIDTH=72%>
			<P>Die WebApp.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=28%>
			<P>/etc/init.d/</P>
		</TD>
		<TD WIDTH=72%>
			<P>Die services, die zum Starten benutzt werden (links zu
			/home/pi/avnav/program/raspberry):<BR>* avnav – der server<BR>*
			check_parts – service, der prüft, ob die data partition schon
			da ist und sie im Zweifel anlegt<BR>* check_wlan – prüft, ob
			das interface wlan0 eine IP adresse hat und macht im Zweifel ein
			ifdown/ifup – damit funktioniert das Wlan deutlich stabiler</P>
		</TD>
	</TR>
</TABLE>
<P>&nbsp;</P>
<P>Bis auf die init scripte läuft die gesamte Software unter dem
  Nutzer pi. Die Installation muss allerdings als root erfolgen.</P>
<P>Standardmässig wird die SD Karte für den pi mit 2 Partitionen
versehen:</P>
<UL>
	<LI><P>eine FAT32 formatierte boot Partition (ca. 60MB), gemounted
	nach /boot</P>
	<LI><P>eine root partition, ca. 2GB</P>
</UL>
<P>Bei meinem Image kommt dazu noch eine separate /data partition mit
dem Rest der SD-Karte (wird beim ersten Start automatisch erzeugt). Das empfiehlt sich in jedem Fall, da für die
Speicherung der Karten sehr viele kleine Dateien erzeugt werden und
die standard-Partitionen darauf nicht gut vorbereitet sind.</P>
<P>Die Installation der Software hängt stark davon ab, ob mein Image
verwendet wird, oder ob von einem „stock“ Image ausgegangen wird.
Beide Varianten beschreibe ich kurz.</P>
<H3 CLASS="western">Installation mit avnav image</H3>
<P>Für diese Variante einfach unter Windows/Linux/OSx das image von
  <a href="http://www.wellenvogel.de/software/avnav/download">wellenvogel.de</a> herunterladen und wie unter <a href="http://www.raspberrypi.org/downloads">http://www.raspberrypi.org/downloads</a> (raw images)  beschrieben auf eine SD Karte
spielen. Danach muss man sich einmal auf dem pi einloggen und ggf.
ein paar Anpassungen vornehmen. Am einfachsten geht das, wenn man den
pi im LAN anschließt und einen router/dhcp-server (z.B. Fritz Box)
aktiv hat. Dann holt er sich per DHCP eine IP Adresse. Diese kann man
auf dem Router sehen bzw. unter Linux z.B. per ping -b
&lt;brodcast-address&gt; herausfinden. Alternativ kann man auch Tastatur + Bildschirm an den Pi direkt anschliessen.</P>
<P>Die Paßworte sind auf Standardwerte gesetzt – also login pi,
Paßwort raspberry. Per sudo -i wechselt man in eine root shell. Man
sollte kontrollieren, ob die /data partition existier und gemounted
ist (df -h, mount). Anschliessend sollte man noch das Paßwort für
den user pi ändern (passwd). Per sudo raspi-config (siehe u.a. <a href="http://www.raspberrypi.org/phpBB3/viewtopic.php?f=91&t=4751">hier</a>) sollte ein Übertakten auf 1GHz
eingestellt werden.</P>
<P>Am schwierigsten kann sich das Aufsetzen des WLAN gestalten. Das
hängt vom verwendeten Adapter ab. Ich habe einen  rtl8192cu
verwendet (TP-Link TL-WN725N). Dazu musste ich den hostapd (/usr/sbin/hostapd)
austauschen gegen den von
<A HREF="http://dl.dropbox.com/u/1663660/hostapd/hostapd.zip">http://dl.dropbox.com/u/1663660/hostapd/hostapd.zip</A>.
Der originale ist noch als hostapd.ori vorhanden – also ggf. wieder
umbennen. Anpassungen zur Konfiguration muss man in
/etc/hostapd/hostapd.conf vornehmen. In jedem Falle sollte hier der
WPA-Key getauscht werden (standard: SSID avnav, pw: avnav-secret).
Ggf. muss man den driver ändern. Danach service hostapd restart und
die WLAN-Verbindung testen. Eine gute Anleitung findet sich unter
<A HREF="http://elinux.org/RPI-Wireless-Hotspot">http://elinux.org/RPI-Wireless-Hotspot</A>.</P>
<P>Das WLAN hat den Adressbereich 192.168.20.0/24. Der pi selbst ist
auf 192.168.20.10 erreichbar (ggf. als url im Browser benutzen, wenn
die Namensauflösung nicht funktioniert). Auf dem pi läuft ein DHCP
server und ein DNS server (dnsmasqd). Die Konfiguration kann
angepasst werden in  /etc/dnsmasqd.conf. Wenn der pi im LAN
angeschlossen ist, versucht er per DHCP eine Adresse zu bekommen, das
WLAN wird per NAT an das LAN interface weitergereicht (damit kann man den pi ins Internet bringen - z.B. zum Installieren von Software- und auch per Wlan verbundene Geräte haben dann Internet-Zugriff).
</P>
<P>Für die Auslieferung der Karten ist der lighthttpd installiert.
Dieser kann gff. Auch für weitere Funktionen genutzt werden. Er ist
jedoch per default auf port 81 aufgesetzt. Port 80 ist direkt zum Web
server von avnav weitergeleitet (dieser lauscht auf port 8080).</P>
<P>Wenn alles richtig aufgesetzt ist, sollte sich unter der url
<A HREF="http://avnav/">http://avnav</A> die Einstiegsseite der
WebApp öffnen.</P>
<P>Mit <em>sudo service avnav status</em> kann man den Status des servers
prüfen, mit <em>sudo service avnav start</em> bzw. <em>sudo service avnav stop</em> kann man ihn starten und stoppen.</P>
<H3 CLASS="western">Installation mit „stock image“</H3>
<P>Hierbei zunächst das debian wheezy image von
<A HREF="http://www.raspberrypi.org/downloads">http://www.raspberrypi.org/downloads</A>
installieren (Anleitung siehe dort). Danach muss man eine Reihe
weiterer Pakete installieren, die Konfigurationen vornehmen und zum
Schluss die avnav software installieren. Nach dem ersten reboot
Übertakten auf 1GHz einstellen.<BR>Hier eine kurze Dokumentation der
Schritte (ohne ganz detaillierte Beschreibung):</P>
<UL>
	<LI><P>gpsd<BR><A HREF="http://blog.retep.org/2012/06/18/getting-gps-to-work-on-a-raspberry-pi/">http://blog.retep.org/2012/06/18/getting-gps-to-work-on-a-raspberry-pi/</A><BR>sudo
	apt-get install gpsd gpsd-clients python-gps</P>
	<LI><P>bluetooth<BR><A HREF="http://www.rpiblog.com/2012/08/bluetooth-pairing-of-raspberry-pi-with.html">http://www.rpiblog.com/2012/08/bluetooth-pairing-of-raspberry-pi-with.html</A><BR>apt-get
	install -y bluetooth [bluez-utils blueman]</P>
	<LI><P>pyserial<BR>copy pyserial to pi
	(<A HREF="https://pypi.python.org/packages/source/p/pyserial/pyserial-2.6.tar.gz#md5=cde799970b7c1ce1f7d6e9ceebe64c98">https://pypi.python.org/packages/source/p/pyserial/pyserial-2.6.tar.gz#md5=cde799970b7c1ce1f7d6e9ceebe64c98</A>)<BR>unpack
	tar -xvzf …<BR>cd into pyserial dir<BR>python setup.py install</P>
	<LI><P> python bluetooth support<BR>sudo apt-get install
	python-bluez</P>
	<LI><P>python udev support<BR>sudo apt-get install python-pyudev</P>
	<LI><P>hotspot - see <A HREF="http://elinux.org/RPI-Wireless-Hotspot">http://elinux.org/RPI-Wireless-Hotspot</A><BR>sudo
	apt-get install hostapd dnsmasqd<BR>we use 192.168.20.00 for our
	wireless setup<BR>20...254 - dhcp raspi<BR>10       - raspi itself</P>
	<LI><P>etc/hosts<BR>192.168.20.10 avnav</P>
	<LI><P>/etc/dnsmasqd.conf<BR>interface=wlan0<BR>domain=avnav<BR>dhcp-range=192.168.20.20,192.168.20.254,255.255.255.0,12h<BR>dhcp-option=42,0.0.0.0</P>
	<LI><P>natting<BR>/etc/sysctl.conf: net.ipv4.ip_forward=1<BR>iptables
	-t nat -A POSTROUTING -o eth0 -j MASQUERADE<BR>iptables -A FORWARD
	-i eth0 -o wlan0 -m state --state RELATED,ESTABLISHED -j
	ACCEPT<BR>iptables -A FORWARD -i wlan0 -o eth0 -j
	ACCEPT<BR>iptables-save &gt; /etc/iptables.ipv4.nat</P>
	<LI><P>/etc/network/interfaces<BR>auto lo<BR>iface lo inet
	loopback<BR>iface eth0 inet dhcp<BR>allow-hotplug wlan0<BR>iface
	wlan0 inet static<BR>address 192.168.20.10<BR>netmask
	255.255.255.0<BR>up iptables-restore &lt; /etc/iptables.ipv4.nat</P>
	<LI><P>/etc/hostapd/hostapd.conf<BR>interface=wlan0<br>
	#driver=nl80211 #original value
	<BR>
	driver=rtl8192cu<BR>ssid=avnav<BR>hw_mode=g<BR>channel=6<BR>macaddr_acl=0<BR>auth_algs=1<BR>ignore_broadcast_ssid=0<BR>wpa=2<BR>wpa_passphrase=avnav-secret<BR>wpa_key_mgmt=WPA-PSK<BR>wpa_pairwise=TKIP<BR>rsn_pairwise=CCMP</P>
	<LI><P>/etc/default/hostapd<BR>DAEMON_CONF=&quot;/etc/hostapd/hostapd.conf&quot;</P>
	<LI><P>check hostapd (see avnav image)</P>
	<LI><P>set up ntp sync<BR>see <A HREF="http://catb.org/gpsd/gpsd.html">http://catb.org/gpsd/gpsd.html</A><BR>
	-- does not work out of the box<BR>as gpsd is running non root, we
	have to enable other SHM segments!<BR>/etc/ntp.conf:<BR>server
	127.127.28.0<BR>fudge 127.127.28.0 time1 0.420 refid GPS<BR>server
	127.127.28.1 prefer<BR>fudge 127.127.28.1 refid GPS1<BR>server
	127.127.28.2<BR>fudge 127.127.28.2 time1 0.420 refid GPS2<BR>server
	127.127.28.3 prefer<BR>fudge 127.127.28.3 refid GPS3</P>
	<LI><P>prevent pi from interacting on boot due to corrupted FS<BR>see
	<A HREF="http://www.raspberrypi.org/phpBB3/viewtopic.php?f=28&amp;t=15870">http://www.raspberrypi.org/phpBB3/viewtopic.php?f=28&amp;t=15870</A><BR>sudo
	vi /etc/default/rcS<BR>change #FSCKFIX=no<BR>to FSCKFIX=yes</P>
	<LI><P>lighthttpd for faster chart delivery<BR>apt-get
	update<BR>apt-get install lighttpd<BR>first shot: configure to port
	81 (so that our redirect from 80 to 8080 can
	remain...):<BR>/etc/lighttpd/lighttpd.conf:<BR>server.port          
	      = 81<BR>alias.url = ( &quot;/charts&quot; =&gt;
	&quot;/data/avnav/charts/&quot; )</P>    
	<LI>enable port forwarding of port 80 to 8080 <br>
	  in /etc/defaults/avnav:<br>
	  FORWARD=8080
    <LI>bluetooth workaround<br>
      bluetoothd crashes on btd-122<br>
      in /etc/default/avnav:<br>
      HCIDEVICES=&quot;hci0 hci1 hci2 hci3 hci4&quot;<br>
      started diese devices wenn avnav started<br>        
  <LI>nstall avnav<BR>Herunterladen der aktuellen Software von
	    <a href="http://www.wellenvogel.de/software/avnav/download">wellenvogel.de</a>. Auspacken des archives als pi im Verzeichnis /home/pi/avnav.
	Danach Aufruf (als root) ./setup.sh part
<LI>checken service avnav status.
</UL>
<P><BR><BR>
</P>
<H2 CLASS="western"><a name="Chartconvert">Konvertieren der Karten</a></H2>
<P>Damit Karten in der WebApp verwendet werden können, müssen sie
in einem „Kachelformat“ vorliegen. Das ist das Format, das durch
Dienste wie OpenStreetMaps oder GoogleMaps benutzt wird. Eine
Kartenkachel ist 256x256 Pixel gross. Die Welt wird dabei auf eine
ebene Fläche projeziert (kann man sich das wie einen Papierzylinder
vorstellen, der senkrecht steht und am Äquator um die Erde gewickelt
wird). Jeder Punkt mit seinen Koordinaten (Länge/Breite) wird dann
auf diesen Zylinder projeziert. Wie man das macht, welche Einheiten
in der Projektion verwendet werden und ob die Erde als Kugel oder
Ellipsoid mit verschiedenen Parametern modelliert wird, beschreiben
die verschiedenen Projektionen. Die WebApp benutzt die sogenannte
Google-Mercator Projektion (die Erde wird dabei als Kugel betrachtet)
 - mit dem EPSG code 900913. Die Einheiten auf dem Papier sind dabei
Meter (die man natürlich in die entsprechenden Koordinaten umrechnen
kann). Karten in einem anderen Format (z.B. WGS84 – Erde als
Ellipsoid, immer in Grad) müssen daher ggf. reprojeziert werden. 
</P>
<P>Die gesamte Projektionsfläche wird bei der google Projektion in
Kacheln unterteilt. Der Zoom level gibt an, in wieviele Kacheln die
Fläche unterteil wird. Zoom level 0 bedeuted: Die gesamte Erde (von
-85° bis +85° Breite – darüber ist die Projektion nicht
definiert) auf einer Kachel von 256x256 Pixel. Mit jedem weiteren
ZoomLevel wird feiner unterteilt: Zoom level 1: 2x2 Kacheln, 2: 4x4
Kacheln usw. Für uns reichen die interessanten Zoom Level von ca. 7
bis 18..19. Das bedeutet (level 19) 2^19x2^19 Kacheln.</P>
<P>Zur Darstellung wird die library <A HREF="http://www.openlayers.org/">openlayers</A>
verwendet. Diese lädt die entsprchenden Kartenkacheln je nach zoom
level vom raspberry und zeigt sie an. OpenStreetMaps verwendet
typischerweise diese Library.</P>
<P>Man kann sich leicht vorstellen, das bei hohen Zoomleveln schnell
große Datenmengen zusammenkommen. Daher müssen wir für unsere
Kartenkacheln ähnlich vorgehen, wie es auch bei den Papierkarten
ist: Für Übersichten ein kleinerer Zoom Level, Detailkarten größer
und z.B. Hafenpläne dann mit level 18 oder 19 (60cm/pixel bzw.
30cm/pixel). Um damit arbeiten zu können, werden die verschiedenen
Detailgrade dann in Layern (Schichten)  übereinandergelegt. Wenn es
für ein Gebiet einen Layer mit besserem (grösserem) zoomlevel gibt,
wird dieser angezeigt, wenn nicht, der mit der geringeren Auflösung
(ggf. noch vergrössert). Um unsere Anzeigegeräte nicht zu
überlasten, kann man typisch mit 3-5 Kartenlayern arbeiten (je nach
Gerät...).</P>
<P>Damit besteht für die Kartenkonvertierung die Aufgabe darin,
vorhandene Karten in solche Layer einzusortieren, sie ggf zu
reprojezieren und dann die Kartenkacheln (sowie eine
Beschreibungsdatei) zu erzeugen. Das erfordert meist eine ganze Menge
Rechenleistung (und ggf. Zeit), daher ist das etwas, dass auf einem
PC oder Laptop laufen sollte (der pi ist dafür zu schwach). Das ist
aber nicht schlimm – man muss das ja nur einmal machen. Belohnt
wird man dafür mit einer sogenannten „blattschnittfreien“
Darstellung.</P>
<P>Das Verfahren dazu hängt von der Quelle ab. Im Moment habe ich
support für 2 „Wege“ der Kartenerstellung eingebaut:</P>
<UL>
	<LI><P>Konvertierung von Karten mittels <A HREF="http://www.gdal.org/">GDAL</A>
	(z.B. BSB) – hier kann alles gelesen werden, was gdal kann</P>
	<LI>
	  <P>Nutzung von downloads mit dem <a href="http://mobac.sourceforge.net/">Mobile Atlas Creator</a>.</P>
</UL>
<H3 CLASS="western">Konvertierung von Karten mit GDAL</H3>
<P>Für diese Konvertierung müssen einige Tools installiert werden.
Das ist zwar leider ein wenig Aufwand, muss aber nur einmalig
erledigt werden. 
</P>
<P>Zunächst wird python (ab 2.6) benötigt. Für Windows (64 Bit)
z.B. von
<A HREF="http://www.python.org/ftp/python/2.7.3/python-2.7.3.amd64.msi">http://www.python.org/ftp/python/2.7.3/python-2.7.3.amd64.msi</A>
. 
</P>
<P>Danach GDAL und GDAL python bindings
(http://www.gisinternals.com/sdk/ -
<A HREF="http://www.gisinternals.com/sdk/PackageList.aspx?file=release-1600-x64-gdal-1-9-2-mapserver-6-2-0.zip">http://www.gisinternals.com/sdk/PackageList.aspx?file=release-1600-x64-gdal-1-9-2-mapserver-6-2-0.zip</A>,
<A HREF="http://www.gisinternals.com/sdk/Download.aspx?file=release-1600-x64-gdal-1-9-2-mapserver-6-2-0">http://www.gisinternals.com/sdk/Download.aspx?file=release-1600-x64-gdal-1-9-2-mapserver-6-2-0</A>\gdal-19-1600-x64-core.msi,
<A HREF="http://www.gisinternals.com/sdk/Download.aspx?file=release-1600-x64-gdal-1-9-2-mapserver-6-2-0">http://www.gisinternals.com/sdk/Download.aspx?file=release-1600-x64-gdal-1-9-2-mapserver-6-2-0</A>\GDAL-1.9.2.win-amd64-py2.7.msi
). Anschliessend GDAL_DATA im environment setzen und GDAL in den Pfad
aufnehmen. 
</P>
<P>Dazu noch PIL für python (
<A HREF="http://www.lfd.uci.edu/~gohlke/pythonlibs/">http://www.lfd.uci.edu/~gohlke/pythonlibs/</A>).</P>
<P>Der Hauptteil der Konvertierung wird durch tiler_tools
durchgeführt, diese ebenfalls herunterladen
(<A HREF="https://code.google.com/p/tilers-tools/">https://code.google.com/p/tilers-tools/</A>)
und in einem Verzeichnis entpacken. 
</P>
<P>Im gleichen Verzeichnis sollte sich das python script
read_charts.py befinden (aus dem download von <a href="http://www.wellenvogel.de/software/avnav/download">wellenvogel.de</a>)</P>
<P>Nach der Installation kann die Konvertierung starten. Für jeden
Kartensatz sollte ein output Verzeichnis vorgesehen werden, in dieses
werden Zwischendateien geschrieben und final unter <strong>tiles</strong> auch die
erzeugten Kacheln. Wenn dieses output Verzeichnis nicht gelöscht
wird, können später in einem update Modus nur die geänderten
Kacheln neu erzeugt werden. Leider gibt es für den Konverter keine grafische Oberfläche, man muss also die Kommandozeile bemühen (cmd unter windows, Terminal auf dem Mac...). </P>
<P>Die Konvertierung verläuft in 2 Schritten:</P>
<UL>
	<LI><P>Sortierung der Karten in layer (und ggf. soweit nötig
	Konvertierung der karten). 
	</P>
	<LI><P>Erzeugung der Kacheln</P>
</UL>
<P>Der erste Schritt geht relativ schnell. Alle Kartendateien werden
gelesen und Auflösung und Abdeckung wird ermittelt (falls nötig
wird konvertiert). Im Ergebnis entsteht im output Verzeichnis eine
Datei chartlist.xml. Der Aufruf dazu lautet:</P>
<PRE>read_charts.py outdir inputdir [inputdir...]
</PRE>
<P>Falls die tiler_tools sich nicht im gleichen Verzeichnis befinden, kann man das mit der Option -a angeben:</P>
<pre>read_charts.py -a \User\SomeUSer\SomeDir\tiler_tools outdir inputdir [inputdir...] </pre>
<P>Anschliessend sollte die chartlist.xml noch einmal mit einem
  Texteditor überprüft werden, manchmal macht es Sinn, Kartendateien
  noch einem anderen Layer zuzuordnen. Das kann einfach durch
  Verschieben des entsprechenden XML Elements erfolgen. Man kann sich dazu an den Namen der Karten orientieren - meist mach es Sinn Karten vergleichbaren Detailgrades in einen Layer zu verschieben.</P>
<P>Der zweite Schritt ist etwas langwieriger, hier erfolgt die
eigentliche Erzeugung der Kartenkacheln. Der Aufruf:</P>
<PRE>read_charts.py outdir
</PRE><P>
Unter outdir muss bereits eine chartlist.xml existieren. Die
Erzeugung läuft multi-threaded, auf einem Dual Core 2x2Ghz ca. 20
min für einen Kartensatz mit ca. 20 Karten. 
</P>
<P>Man kann auch beide Schritte kombinieren – dazu einfach -m all
noch vor den anderen Parametern bei Schritt 1 angeben:</P>
<PRE>read_charts.py -m all outdir inputdir
</PRE><P>
Falls sich einige Karten geändert haben (z.B. Chart Updates), kann
man Schritt 2 einfach wiederholen mit dem Parameter -u:</P>
<PRE>read_charts.py -u outdir
</PRE>
<P>
Als Ergebnis erhält man unter outdir/tiles eine Datei avnav.xml
sowie ein Verzeichnis für jeden layer (mit weiteren
Unterverzeichnissen). Der Inhalt dieses tiles Verzeichnisses muss dann auf
den raspberry kopiert werden – in ein separates Verzeichnis unter
/data/avnav/charts. Dazu kann man unter Windows sinnvoll winscp
benutzen. Am Ende muss z.B. im Verzeichnis /data/avnav/charts/Satz1
eine Datei avnav.xml vorhanden sein, darunter dann die
Layer-Verzeichnisse.</P>
<H3 CLASS="western">Nutzung von Karten mit dem Mobile Atlas Creator</H3>
<P>Für die Nutzung  des Mobile Atlas Creators ist keine weitere
Software auf dem PC/Laptop nötig. Man muss beim Download der Karten
allerdings ein gewisses Schema einhalten, damit die Karten in das
oben beschriebene Layer-Konzept passen und die Datenmengen
überschaubar bleiben. 
</P>
<P>Dazu sollte man (je nach Kartenquelle) z.B. 3 Layer vorsehen:
Übersicht( Zoom Level 7-10) Navigation (level 10-15), Details (Level
16-18). Anschliessend sollte man im MOBAC layerweise vorgehen. Dazu
jeweils als gewünschte Zoomlevel die zum Layer gehörigen anklicken
(links oben), danach alle Teilbereiche jeweils markieren und unter
einem beliebigen Namen dem Atlas hinzufügen. Das jeweils für die
anderen Layer wiederholen (dabei sinnvolle Auswahlen treffen).
Anschliessend die Atlas-Konfiguration unter einem beliebigen Namen
speichern. Als output Format OSMTracker wählen und die
Atlas-Erzeugung starten. Im output Verzeichnis entsteht ein
Verzeichnis für jeden Zoom level. Diese Verzeichnisse wieder auf den
pi unter /data/avnav/charts/Satzx kopieren. Den Atlas speichern (Profil speichern). Diese Datei (liegt im Programmverzeichnis von MOBAC)  in das
gleiche Verzeichnis kopieren (der server wird automatisch eine
avnav.xml erzeugen). Dazu darauf achten, dass man Karten als Nutzer pi auf den raspberry kopiert - zumindest das Wurzelverzeichnis muss für pi schreibbar sein, sonst kann die avnav.xml nicht erzeugt werden.</P>
<P>&nbsp;</P>
<H2 CLASS="western">Die WebApp</H2>
<P>Um die auf dem raspberry pi installierten Karten nutzen zu können,
gibt es eine in HTML/Java Script geschriebene WebApp. Dazu noch ein
Hinweis vorweg:</P>
<P>I<I><B>ch kann keine Garantie für die Funktion der App
übernehmen, insbesondere die Nutzung zu Navigationszwecken geschieht
auf eigenes Risiko. In jedem Falle empfehle ich einen intensiven Test
der Genauigkeit der Darstellung und des verwendeten Kartenmaterials.</B></I></P>
<P>Die App kommuniziert mit dem webserver des avnav_server.py auf dem
pi. Die Einstiegsseite ist unter der url
<A HREF="http://avnav/viewer/avnav_viewer.html">http://avnav/viewer/avnav_viewer.html</A>
erreichbar. Es is eine sogenannte „single page app“, d.h. Die
weitere Kommunikation mit dem server geschieht per Ajax durch den
JavaScript Anteil. Vom Layout ist sie optimiert für die Darstellung
auf einem 7 Zoll Tablet (bei mir momentan im Einsatz: Nexus 7 am
Navitisch, Blackberry Playbook draussen), sie läuft aber natürlich
auch auf größeren Tablets (Ipad) oder auf einem Laptop/Desktop.
Eine sinnvolle Nutzung ist ab etwa 900x540 Pixel möglich.</P>
<P>Diese App befindet sich noch in einem recht frühen
Entwicklungsstadium, ich habe sie allerdings selbst schon intensiv in
Benutzung. Ihre wesentlichen Fähigkeiten:</P>
<UL>
	<LI><P>Darstellung der Kartendaten (blattschnittfrei je Satz),  mit
	den enstprechenden Funktionen (Zoom, move,...)</P>
	<LI><P>Dartstellung der aktuellen Schiffsposition mit Kurs,
	Geschwindigkeit (mit Lock der Karte auf Schiffsposition)</P>
	<LI><P>Darstellung des aktuellen Tracks</P>
	<LI><P>Setzen eines Wegepunktes, Anzeige von Richtung,Entfernung,ETA</P>
	<LI><P>AIS Anzeige mit Darstellung in der Karte, AIS Target am
	nächsten zum Schiff, Warnung bei CPA &lt; 500m, CPA,TCPA, AIS Infos</P>
</UL>
<P>Im Folgenden beschreibe ich kurz die Bedienung der aktuellen
Version, danach einige technische Details.</P>
<H3 CLASS="western">Die Bedienung</H3>
<P>Nach dem Aufruf der Start-Url landet man auf der Einstigesseite.</P>
<P><IMG SRC="navi-start.png" NAME="Grafik3"  WIDTH=600 BORDER=0>
</P>
<P>Im Hauptbereich der Seite befindet sich die Liste der vom Server
gefundenen Kartensätze (Verzeichnisse unter /data/avnav/charts mit
einer avnav.xml Datei). Durch Anklicken gelang man zur
Navigationsseite mit dem enstprechenden Kartensatz.</P>
<P>Wie auf allen Seiten befindet sich am rechten Rand eine
Button-Leiste. Von hier aus erreich man eine Status-Seite des Servers
und die Hilfe.</P>
<H4 CLASS="western">Die Navigationsseite</H4>
<P><IMG SRC="navi-1.png" NAME="Grafik4" WIDTH=600  BORDER=0>
</P>
<P>Dies ist die Hauptansicht. In der Mitte befindet sich die
Kartenansicht mit der Schiffsposition (roter Pfeil). Die gelben und
grünen Dreiecke mit Pfeilspitzen sind empfangene AIS Ziele in der
Nähe (10nm) mit ihrem aktuellen Kurs sowie Name oder MMSI. Die
organgefarbene Linie zeigt zum aktiven Wegepunkt. Die Karte kann mit
den normalen Gesten verschoben oder gezoomt werden, zum zoomen können
auch die Buttons +/- auf der rechten Leiste benutzt werden. 
</P>
<P>Links befindet sich die Darstellung des nächsten AIS Zieles
(geringste momentane Entfernung). Dieses färbt sich rot, wenn eine
CPA von 500m unterschritten wird. Gelb bedeuted, dass nicht das
nächste Ziel sondern ein separat ausgewähltes Ziel (siehe unten 
AIS) angezeigt wird. Ein Klick auf diese Fläche oder ein AIS Ziel
auf der Karte führt auf die AIS Info Liste (s.u.).</P>
<P>Im unteren Bereich befindet sich die Anzeige der wichtigsten
Navigationsdaten. Links die Daten des aktuellen Wegepunktes (Marker):</P>
<UL>
	<LI><P>Position</P>
	<LI><P>ETA</P>
	<LI><P>Kurs</P>
	<LI><P>Distanz (nm)</P>
</UL>
<P>Danach folgen die Schiffsdaten:</P>
<UL>
	<LI><P>Kurs</P>
	<LI><P>Geschwindigkeit (kn)</P>
	<LI><P>Position</P>
	<LI><P>aktuelle (lokale) Zeit vom GPS</P>
	<LI><P>GPS Indikator: grün – GPS Daten vorhanden, rot: keine
	Daten 
	</P>
</UL>
<P>Ein Klick auf die linke bzw. rechte Seite der Leiste zentriert die
Karte jeweils auf den Wegepunkt bzw. die Bootsposition.</P>
<P>Auf der rechten Seite befindet sich eine Button-Leiste:</P>
<TABLE WIDTH=90% BORDER=1 CELLPADDING=4 CELLSPACING=4>
	<COL WIDTH=89>
	<COL WIDTH=641>
	<TR VALIGN=TOP>
		<TH WIDTH=89>
			<P ALIGN=CENTER>Button 
			</P>
		</TH>
		<TH WIDTH=641>
			<P>Funktion 
			</P>
		</TH>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=89>
			<P ALIGN=CENTER>+</P>
		</TD>
		<TD WIDTH=641>
			<P>Zoom in</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=89>
			<P ALIGN=CENTER>-</P>
		</TD>
		<TD WIDTH=641>
			<P>Zoom out</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=89>
			<P ALIGN=CENTER><IMG SRC="../viewer/images/Layer40.png" NAME="Grafik5" ALIGN=LEFT WIDTH=60 HEIGHT=52 BORDER=0><BR CLEAR=LEFT><BR>
			</P>
		</TD>
		<TD WIDTH=641>
			<P>Anzeige eines Layermenüs. Hiermit können einzelne
			Karten-Layer oder auch Funktionen wie z.B. die AIS oder die
			Wegepunkt-Darstellung ein- oder ausgeschaltet werden.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=89>
			<P ALIGN=CENTER><IMG SRC="../viewer/images/Sail-Boat-40.png" NAME="Grafik7" ALIGN=LEFT WIDTH=59 HEIGHT=59 BORDER=0><BR CLEAR=LEFT><BR>
			</P>
		</TD>
		<TD WIDTH=641>
			<P>Boat „lock“. Wenn dieser Lock eingeschaltet ist (grüner
			Rand) wird die Karte immer auf die Bootsposition zentriert.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=89>
			<P ALIGN=CENTER><IMG SRC="../viewer/images/Marker1.png" NAME="Grafik6" ALIGN=LEFT WIDTH=71 HEIGHT=71 BORDER=0><BR CLEAR=LEFT><BR>
			</P>
		</TD>
		<TD WIDTH=641>
			<P>Marker „lock“. Wenn der Lock ausgeschaltet ist, springt der
			Marker in die Mitte der angezeigten Karte. In diesem Zustand kann
			man die Karte verschieben bis sich der Marker an der gewünschten
			Stelle (=Wegepunkt) befindet. Mit Klick auf den Marker button
			erscheint ein grüner Rand und die Kurslinie zum Marker wird
			angezeigt. Der Marker bleibt auf dieser Position.</P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=89>
			<P ALIGN=CENTER><IMG SRC="../viewer/images/Cancel40.png" NAME="Grafik8" ALIGN=LEFT WIDTH=66 HEIGHT=55 BORDER=0><BR CLEAR=LEFT><BR>
			</P>
		</TD>
		<TD WIDTH=641>
			<P>Zurück zur Einstiegsseite. Die aktuelle Kartenposition, die
			Marker-Position und der aktuelle zoom bleiben erhalten wenn auf
			einen anderen Kartensatz gewechselt wird.</P>
		</TD>
	</TR>
</TABLE>
<P> 
</P>
<P>Eine typische Bedienfolge:</P>
<P>Waypoint setzen:</P>
<P>unlock Boot-&gt;unlock Marker-&gt;Karte verschieben bis Marker auf
gewünschter Pos (Zoom nutzen)-&gt;lock Marker-&gt;lock Boot 
</P>
<P><IMG SRC="navi-2.png" NAME="Grafik9" WIDTH=600  BORDER=0 ALIGN=middle><BR CLEAR=RIGHT>Dieses
Bild zeigt einen gesetzten Marker (locked) – das Boot ist
allaerdings noch nicht auf Kurs (daher noch keine ETA).</P>
<P>Mit einem Klick auf die AIS Info gelangt man zur AIS Übersicht:</P>
<P><IMG SRC="navi-ais.png" NAME="Grafik10" WIDTH=600  BORDER=0><BR CLEAR=RIGHT>Auf
dieser Seite sieht man alle empfangenen AIS Ziele im Umkreis von ca.
10nm zur Bootsposition (sortiert nach CPA). Mit Klick auf eine Zeile
springt man zurück zur Karten-Anzeige mit dem gewählten AIS Ziel im
Zentrum. Das gewählte Ziel erscheint auch im AIS Info Fenster
(dieses färbt sich gelb). Ein Klick auf den grünen Pfeil schaltet
wieder in den „Normalmodus“ - d.h. Anzeige des nächsten AIS
Zieles.</P>
<P>Mit dem zurück Button geht es unverändert zur Karten-Anzeige
zurück.</P>
<P>Wenn man einen Wegepunkt aktiv hat (Marker Button grün) und die Karte nicht auf das Schiff &quot;gelockt&quot; ist (Schiffsbutton nicht grün), wird beim Bewegen der Karte ein Kreuz im Zentrum gezeigt und unten erscheint eine Anzeig des aktuellen Abstandes vom Marker bzw. Schiff zum Kartenmittelpunkt. Damit kann man einfache Peilungen machen - Mittelpunkt auf Peilziel verschieben und Peilung ablesen.</P>
<P><img src="center-measure.PNG" width="600" alt="center"></P>
<P>Die Anzeige verschwindet nach 45s automatisch, wenn die Karte nicht bewegt wird, laternativ durch Klick auf die Daten.</P>
<P>Von der Startseite kann man noch eine Status-Seite erreichen –
hier werden interne Status-Infos des Servers angezeigt.</P>
<P><IMG SRC="navi-status.png" NAME="Grafik11" WIDTH=600  BORDER=0><BR CLEAR=RIGHT>Wichtig
ist hier insbesondere der Status der „Serial reader“ - dieser
zeigt, ob sie NMEA Daten empfangen.</P>
<H2 CLASS="western">Lizenzen und verwendete Libraries</H2>
<TABLE WIDTH=90% BORDER=1 CELLPADDING=4 CELLSPACING=4>
	<COL WIDTH=85*>
	<COL WIDTH=85*>
	<COL WIDTH=85*>
	<TR VALIGN=TOP>
		<TH WIDTH=33%>
			<P>Library</P>
		</TH>
		<TH WIDTH=33%>
			<P>Link</P>
		</TH>
		<TH WIDTH=33%>
			<P>Lizenz</P>
		</TH>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=33%>
			<P>OpenLayers (2.12)</P>
		</TD>
		<TD WIDTH=33%>
			<P><A HREF="http://www.openlayers.org/">http://www.openlayers.org/</A></P>
		</TD>
		<TD WIDTH=33%>
			<P><A HREF="http://openlayers-licence.txt/">2-clause BSD licence</A></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=33%>
			<P>Jquery 1.9.1.</P>
		</TD>
		<TD WIDTH=33%>
			<P><A HREF="http://jquery.com/">http://jquery.com/</A></P>
		</TD>
		<TD WIDTH=33%>
			<P><A HREF="http://LICENSE-MIT.txt/">MIT licence</A></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=33%>
			<P>Iquery UI</P>
		</TD>
		<TD WIDTH=33%>
			<P><A HREF="http://jqueryui.com/">http://jqueryui.com/</A></P>
		</TD>
		<TD WIDTH=33%>
			<P><A HREF="http://LICENSE-MIT.txt/">MIT licence</A></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=33%>
			<P>Tiler tools</P>
		</TD>
		<TD WIDTH=33%>
			<P><A HREF="https://code.google.com/p/tilers-tools/">https://code.google.com/p/tilers-tools/</A></P>
		</TD>
		<TD WIDTH=33%>
			<P><A HREF="http://LICENSE-MIT.txt/">MIT licence</A></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=33%>
			<P>Movable type</P>
		</TD>
		<TD WIDTH=33%>
			<P><A HREF="http://www.movable-type.co.uk/scripts/latlong.html">http://www.movable-type.co.uk/scripts/latlong.html</A></P>
		</TD>
		<TD WIDTH=33%>
			<P><A HREF="http://attribution-licence.pdf/">Simple attribution
			licence</A></P>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD WIDTH=33%>
			<P>gpsd</P>
		</TD>
		<TD WIDTH=33%>
			<P><A HREF="http://www.catb.org/gpsd/">http://www.catb.org/gpsd/</A></P>
		</TD>
		<TD WIDTH=33%>
			<P><A HREF="http://ModifiedBSDLicence.html/">Modified BSD License</A></P>
		</TD>
	</TR>
</TABLE>
<P><BR><BR>
</P>
<P>Diese Software: MIT Licence</P>
<DIV ID="block-system-main" DIR="LTR">
	<DIV ID="node-66" DIR="LTR">
		<H4 CLASS="western">The MIT License (MIT)</H4>
		<P>Copyright (c) 2013 Andreas Vogel http://www.wellenvogel.de</P>
		<P>Permission is hereby granted, free of charge, to any person
		obtaining a copy<BR>of this software and associated documentation
		files (the &quot;Software&quot;), to deal<BR>in the Software
		without restriction, including without limitation the rights<BR>to
		use, copy, modify, merge, publish, distribute, sublicense, and/or
		sell<BR>copies of the Software, and to permit persons to whom the
		Software is<BR>furnished to do so, subject to the following
		conditions:</P>
		<P>The above copyright notice and this permission notice shall be
		included in<BR>all copies or substantial portions of the Software.</P>
		<P>THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF
		ANY KIND, EXPRESS OR<BR>IMPLIED, INCLUDING BUT NOT LIMITED TO THE
		WARRANTIES OF MERCHANTABILITY,<BR>FITNESS FOR A PARTICULAR PURPOSE
		AND NONINFRINGEMENT. IN NO EVENT SHALL THE<BR>AUTHORS OR COPYRIGHT
		HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER<BR>LIABILITY,
		WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
		FROM,<BR>OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
		OTHER DEALINGS IN<BR>THE SOFTWARE.</P>
	</DIV>
</DIV>
<P><BR><BR>
</P>
<P><BR><BR>
</P>
<H3 CLASS="western">Technische Infos</H3>
<P>Die WebApp kommuniziert mit dem server (Stand heute) „read only“
- d.h. sie liest nur Daten, verändert aber keine Daten auf dem
Server. Das Setzen des Markers ist somit eine rein lokale Sache, wenn
man auf einem Display-Gerät den Marker setzt, beeinflusst das nicht
die Anzeige auf den anderen Geräten. Das wird sich in zukünftigen
Versionen ändern.</P>
<P>Sie besteht aus einem HTML Gerüst (avnav_viewer.html) sowie den
eingebundenen JavaScript Bibliotheken und einem JavaScript Anteil
(avnav_viewer.js). Die Darstellung ist weitgehend von der
eigentlichen Funktion entkoppelt und wird per css (unter Nutzung von
less) gesteuert. Man kann die Darstellung in der HTMl Datei und in
avnav_viewer.less weitgehend anpassen.</P>
<P>Die Kommunikation erfolgt durch einfache GET requests zur url
<A HREF="http://avnav/viewer/avnav_navi.php">http://avnav/viewer/avnav_navi.php</A>,
dann folgen Parameter, die den request beschreiben. Die Antworten vom
server sind json kodiert.</P>
<P>Die wichtigsten requests sind:</P>
<UL>
	<LI><P>gps: Abfrage der Positionsdaten 
	</P>
	<LI><P>ais: Abfrage der AIS Daten 
	</P>
	<LI><P>track: Abfrage des aktuellen Tracks</P>
</UL>
<P>Diese Requests werden periodisch wiederholt (polling).</P>
<P>Viele Parameter lassen sich in der Variable properties am Anfang
der Java Script Datei einstellen.</P>
</BODY>
</HTML>
